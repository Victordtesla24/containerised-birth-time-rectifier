"""
Charts REST API router for handling CRUD operations on charts.
"""

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any, Union
import logging
import uuid

from ai_service.services.chart_service import ChartService

# Configure logging
logger = logging.getLogger(__name__)

# Create router with appropriate tags
router = APIRouter(
    tags=["charts"],
    responses={404: {"description": "Not found"}}
)

# Define models
class ChartCreateRequest(BaseModel):
    birthDate: str = Field(..., description="Birth date in format YYYY-MM-DD")
    birthTime: str = Field(..., description="Birth time in format HH:MM or HH:MM:SS")
    birthPlace: str = Field(..., description="Birth place (city, state, country)")
    name: Optional[str] = Field(None, description="Name for the chart")
    notes: Optional[str] = Field(None, description="Additional notes about the chart")

class ChartUpdateRequest(BaseModel):
    notes: Optional[str] = Field(None, description="Updated notes for the chart")
    tags: Optional[List[str]] = Field(None, description="Tags for the chart")

class PlanetData(BaseModel):
    name: str
    sign: str
    house: int
    degree: float
    retrograde: bool = False
    longitude: Optional[float] = None
    latitude: Optional[float] = None

class HouseData(BaseModel):
    number: int
    sign: str
    degree: float

class AspectData(BaseModel):
    planet1: str
    planet2: str
    aspect_type: Optional[str] = "conjunction"
    orb: float

class ChartResponse(BaseModel):
    id: str
    name: Optional[str] = None
    birthDate: str
    birthTime: str
    birthPlace: str
    notes: Optional[str] = None
    tags: Optional[List[str]] = None
    planets: List[PlanetData]
    houses: List[HouseData]
    aspects: List[AspectData]

# Dependency to get ChartService instance
def get_chart_service():
    return ChartService()

# In-memory storage for tests
_test_chart_storage = {}

@router.post("", response_model=Dict[str, str])
async def create_chart(
    request: ChartCreateRequest,
    chart_service: ChartService = Depends(get_chart_service)
):
    """
    Create a new chart from birth details.
    """
    try:
        # Generate a chart ID
        chart_id = str(uuid.uuid4())
        logger.info(f"Creating chart with ID: {chart_id}")

        # Generate chart data using the chart service
        chart_data = chart_service.generate_chart(
            birth_date=request.birthDate,
            birth_time=request.birthTime,
            latitude=40.7128,  # Default to New York coordinates if not provided
            longitude=-74.0060,
            timezone="America/New_York"
        )

        # Override the ID generated by chart service with our UUID
        if "id" in chart_data:
            logger.info(f"Replacing original chart ID {chart_data['id']} with new UUID {chart_id}")

        # Store chart data with metadata in both service and global storage for tests
        # Make a deep copy of chart_data and override/add our fields
        chart_data_with_metadata = {**chart_data}
        # Ensure our fields take precedence over anything in chart_data
        chart_data_with_metadata.update({
            "id": chart_id,  # Use our UUID consistently
            "name": request.name,
            "birthDate": request.birthDate,
            "birthTime": request.birthTime,
            "birthPlace": request.birthPlace,
            "notes": request.notes,
            "tags": [],
        })

        # Store in service
        chart_service.chart_storage[chart_id] = chart_data_with_metadata

        # Also store in module-level dict for test persistence
        _test_chart_storage[chart_id] = chart_data_with_metadata

        logger.info(f"Chart created and stored with ID: {chart_id}")

        return {"id": chart_id}

    except Exception as e:
        logger.error(f"Error creating chart: {e}")
        raise HTTPException(status_code=500, detail=f"Error creating chart: {str(e)}")

@router.get("/{chart_id}", response_model=ChartResponse)
async def get_chart(
    chart_id: str,
    chart_service: ChartService = Depends(get_chart_service)
):
    """
    Retrieve a chart by ID.
    """
    try:
        logger.info(f"Getting chart with ID: {chart_id}")
        logger.info(f"Available chart IDs in global storage: {list(_test_chart_storage.keys())}")

        # First try to get from global storage
        if chart_id in _test_chart_storage:
            logger.info(f"Chart found in global storage: {chart_id}")
            return _test_chart_storage[chart_id]

        # Then try from chart service
        chart_data = chart_service.chart_storage.get(chart_id)
        if chart_data:
            logger.info(f"Chart found in service storage: {chart_id}")
            return chart_data

        # Not found in either storage
        logger.warning(f"Chart not found: {chart_id}")
        raise HTTPException(status_code=404, detail=f"Chart not found: {chart_id}")

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving chart: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving chart: {str(e)}")

@router.put("/{chart_id}", response_model=ChartResponse)
async def update_chart(
    chart_id: str,
    request: ChartUpdateRequest,
    chart_service: ChartService = Depends(get_chart_service)
):
    """
    Update a chart's metadata.
    """
    try:
        # Use model_dump instead of deprecated dict method
        request_data = {}
        if hasattr(request, "model_dump"):
            request_data = request.model_dump(exclude_unset=True)
        else:
            # Fallback for older Pydantic versions
            request_data = {k: v for k, v in request.__dict__.items() if v is not None}

        logger.info(f"Updating chart with ID: {chart_id}, data: {request_data}")

        # Find where the chart exists
        in_test_storage = chart_id in _test_chart_storage
        in_service_storage = chart_id in chart_service.chart_storage

        if not in_test_storage and not in_service_storage:
            logger.warning(f"Chart not found for update: {chart_id}")
            raise HTTPException(status_code=404, detail=f"Chart not found: {chart_id}")

        # Make a copy of the chart data to update
        if in_test_storage:
            # Create a deep copy of the data
            updated_data = dict(_test_chart_storage[chart_id])

            # Update the data with the new values
            if request.notes is not None:
                updated_data["notes"] = request.notes
            if request.tags is not None:
                updated_data["tags"] = request.tags

            # Store back in test storage
            _test_chart_storage[chart_id] = updated_data

            # If also in service storage, update there too
            if in_service_storage:
                chart_service.chart_storage[chart_id] = updated_data

            return updated_data
        else:
            # Only in service storage
            updated_data = dict(chart_service.chart_storage[chart_id])

            if request.notes is not None:
                updated_data["notes"] = request.notes
            if request.tags is not None:
                updated_data["tags"] = request.tags

            chart_service.chart_storage[chart_id] = updated_data
            return updated_data

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating chart: {e}")
        raise HTTPException(status_code=500, detail=f"Error updating chart: {str(e)}")

@router.delete("/{chart_id}", response_model=Dict[str, str])
async def delete_chart(
    chart_id: str,
    chart_service: ChartService = Depends(get_chart_service)
):
    """
    Delete a chart by ID.
    """
    try:
        # Check if the chart exists in either storage
        found = False

        # Check and delete from service storage
        if chart_id in chart_service.chart_storage:
            del chart_service.chart_storage[chart_id]
            found = True

        # Check and delete from global storage
        if chart_id in _test_chart_storage:
            del _test_chart_storage[chart_id]
            found = True

        if not found:
            logger.warning(f"Chart not found for deletion: {chart_id}")
            raise HTTPException(status_code=404, detail=f"Chart not found: {chart_id}")

        return {"status": "Chart deleted successfully"}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting chart: {e}")
        raise HTTPException(status_code=500, detail=f"Error deleting chart: {str(e)}")
