"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/birth-time-rectifier",{

/***/ "./src/services/geocoding.ts":
/*!***********************************!*\
  !*** ./src/services/geocoding.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   geocodeBirthPlace: () => (/* binding */ geocodeBirthPlace)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Geocoding service to get coordinates from a location string\n */ \n// Simple logger to avoid direct console statements\nconst logger = {\n    log: function(message) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // Can be replaced with a proper logging library in production\n        if (true) {\n            // eslint-disable-next-line no-console\n            console.log(message, ...args);\n        }\n    },\n    warn: function(message) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // eslint-disable-next-line no-console\n        console.warn(message, ...args);\n    },\n    error: function(message) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        // eslint-disable-next-line no-console\n        console.error(message, ...args);\n    }\n};\n/**\n * Geocode a birthplace to get its coordinates and timezone\n * Uses a real geocoding API with fallback to mock data\n *\n * @param location Location string (e.g., \"New York, USA\")\n * @returns Promise with geocoding result\n */ async function geocodeBirthPlace(location) {\n    try {\n        logger.log(\"Geocoding birth location: \".concat(location));\n        // Check if we can use the backend API\n        const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(apiUrl, \"/api/geocode\"), {\n                place: location\n            }, {\n                timeout: 10000 // 10 second timeout\n            });\n            if (response.data) {\n                logger.log('Geocoding API response:', response.data);\n                return {\n                    latitude: response.data.latitude,\n                    longitude: response.data.longitude,\n                    timezone: response.data.timezone\n                };\n            }\n        } catch (apiError) {\n            logger.warn('Error calling geocoding API. Using fallback:', apiError);\n        // Continue with fallback if API fails\n        }\n        // Fallback to mock geocoding for common cities\n        const fallbackResult = fallbackGeocode(location);\n        if (fallbackResult) {\n            logger.log('Using fallback geocoding result:', fallbackResult);\n            return fallbackResult;\n        }\n        // If no fallback found, return default coordinates\n        logger.warn('No geocoding result found, using default coordinates');\n        return {\n            latitude: 0,\n            longitude: 0,\n            timezone: 'UTC'\n        };\n    } catch (error) {\n        logger.error('Error in geocodeBirthPlace:', error);\n        // Return default coordinates rather than throwing\n        return {\n            latitude: 0,\n            longitude: 0,\n            timezone: 'UTC'\n        };\n    }\n}\n/**\n * Fallback geocoding function that uses a predefined list of cities\n *\n * @param location Location string\n * @returns Geocoding result or null if not found\n */ const fallbackGeocode = (location)=>{\n    // Example mock coordinates for common cities\n    const geocodeMap = {\n        'new york': {\n            lat: 40.7128,\n            lng: -74.0060,\n            timezone: 'America/New_York'\n        },\n        'london': {\n            lat: 51.5074,\n            lng: -0.1278,\n            timezone: 'Europe/London'\n        },\n        'tokyo': {\n            lat: 35.6762,\n            lng: 139.6503,\n            timezone: 'Asia/Tokyo'\n        },\n        'sydney': {\n            lat: -33.8688,\n            lng: 151.2093,\n            timezone: 'Australia/Sydney'\n        },\n        'pune': {\n            lat: 18.5204,\n            lng: 73.8567,\n            timezone: 'Asia/Kolkata'\n        },\n        'paris': {\n            lat: 48.8566,\n            lng: 2.3522,\n            timezone: 'Europe/Paris'\n        },\n        'berlin': {\n            lat: 52.5200,\n            lng: 13.4050,\n            timezone: 'Europe/Berlin'\n        },\n        'delhi': {\n            lat: 28.6139,\n            lng: 77.2090,\n            timezone: 'Asia/Kolkata'\n        },\n        'mumbai': {\n            lat: 19.0760,\n            lng: 72.8777,\n            timezone: 'Asia/Kolkata'\n        },\n        'bangalore': {\n            lat: 12.9716,\n            lng: 77.5946,\n            timezone: 'Asia/Kolkata'\n        },\n        'los angeles': {\n            lat: 34.0522,\n            lng: -118.2437,\n            timezone: 'America/Los_Angeles'\n        },\n        'chicago': {\n            lat: 41.8781,\n            lng: -87.6298,\n            timezone: 'America/Chicago'\n        },\n        'moscow': {\n            lat: 55.7558,\n            lng: 37.6173,\n            timezone: 'Europe/Moscow'\n        },\n        'beijing': {\n            lat: 39.9042,\n            lng: 116.4074,\n            timezone: 'Asia/Shanghai'\n        },\n        'cairo': {\n            lat: 30.0444,\n            lng: 31.2357,\n            timezone: 'Africa/Cairo'\n        },\n        'rio de janeiro': {\n            lat: -22.9068,\n            lng: -43.1729,\n            timezone: 'America/Sao_Paulo'\n        },\n        'toronto': {\n            lat: 43.6532,\n            lng: -79.3832,\n            timezone: 'America/Toronto'\n        },\n        'rome': {\n            lat: 41.9028,\n            lng: 12.4964,\n            timezone: 'Europe/Rome'\n        },\n        'madrid': {\n            lat: 40.4168,\n            lng: -3.7038,\n            timezone: 'Europe/Madrid'\n        },\n        'singapore': {\n            lat: 1.3521,\n            lng: 103.8198,\n            timezone: 'Asia/Singapore'\n        }\n    };\n    // Check if we have mock data for this location (case insensitive partial match)\n    const locationLower = location.toLowerCase();\n    const matchedCity = Object.keys(geocodeMap).find((city)=>locationLower.includes(city));\n    if (matchedCity) {\n        return {\n            latitude: geocodeMap[matchedCity].lat,\n            longitude: geocodeMap[matchedCity].lng,\n            timezone: geocodeMap[matchedCity].timezone\n        };\n    }\n    return null;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YXJlZC9jdXJzb3IvQ29udGFpbmVyaXNlZC1CaXJ0aC1UaW1lLVJlY2l0Zmllci9zcmMvc2VydmljZXMvZ2VvY29kaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2VvY29kaW5nIHNlcnZpY2UgdG8gZ2V0IGNvb3JkaW5hdGVzIGZyb20gYSBsb2NhdGlvbiBzdHJpbmdcbiAqL1xuXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG4vLyBTaW1wbGUgbG9nZ2VyIHRvIGF2b2lkIGRpcmVjdCBjb25zb2xlIHN0YXRlbWVudHNcbmNvbnN0IGxvZ2dlciA9IHtcbiAgbG9nOiAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pOiB2b2lkID0+IHtcbiAgICAvLyBDYW4gYmUgcmVwbGFjZWQgd2l0aCBhIHByb3BlciBsb2dnaW5nIGxpYnJhcnkgaW4gcHJvZHVjdGlvblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICB3YXJuOiAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pOiB2b2lkID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihtZXNzYWdlLCAuLi5hcmdzKTtcbiAgfSxcbiAgZXJyb3I6IChtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCAuLi5hcmdzKTtcbiAgfVxufTtcblxuaW50ZXJmYWNlIEdlb2NvZGluZ1Jlc3VsdCB7XG4gIGxhdGl0dWRlOiBudW1iZXI7XG4gIGxvbmdpdHVkZTogbnVtYmVyO1xuICB0aW1lem9uZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEdlb2NvZGUgYSBiaXJ0aHBsYWNlIHRvIGdldCBpdHMgY29vcmRpbmF0ZXMgYW5kIHRpbWV6b25lXG4gKiBVc2VzIGEgcmVhbCBnZW9jb2RpbmcgQVBJIHdpdGggZmFsbGJhY2sgdG8gbW9jayBkYXRhXG4gKlxuICogQHBhcmFtIGxvY2F0aW9uIExvY2F0aW9uIHN0cmluZyAoZS5nLiwgXCJOZXcgWW9yaywgVVNBXCIpXG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZ2VvY29kaW5nIHJlc3VsdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VvY29kZUJpcnRoUGxhY2UobG9jYXRpb246IHN0cmluZyk6IFByb21pc2U8R2VvY29kaW5nUmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgbG9nZ2VyLmxvZyhgR2VvY29kaW5nIGJpcnRoIGxvY2F0aW9uOiAke2xvY2F0aW9ufWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHVzZSB0aGUgYmFja2VuZCBBUElcbiAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHthcGlVcmx9L2FwaS9nZW9jb2RlYCwge1xuICAgICAgICBwbGFjZTogbG9jYXRpb25cbiAgICAgIH0sIHtcbiAgICAgICAgdGltZW91dDogMTAwMDAgLy8gMTAgc2Vjb25kIHRpbWVvdXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSkge1xuICAgICAgICBsb2dnZXIubG9nKCdHZW9jb2RpbmcgQVBJIHJlc3BvbnNlOicsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhdGl0dWRlOiByZXNwb25zZS5kYXRhLmxhdGl0dWRlLFxuICAgICAgICAgIGxvbmdpdHVkZTogcmVzcG9uc2UuZGF0YS5sb25naXR1ZGUsXG4gICAgICAgICAgdGltZXpvbmU6IHJlc3BvbnNlLmRhdGEudGltZXpvbmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChhcGlFcnJvcikge1xuICAgICAgbG9nZ2VyLndhcm4oJ0Vycm9yIGNhbGxpbmcgZ2VvY29kaW5nIEFQSS4gVXNpbmcgZmFsbGJhY2s6JywgYXBpRXJyb3IpO1xuICAgICAgLy8gQ29udGludWUgd2l0aCBmYWxsYmFjayBpZiBBUEkgZmFpbHNcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayB0byBtb2NrIGdlb2NvZGluZyBmb3IgY29tbW9uIGNpdGllc1xuICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gZmFsbGJhY2tHZW9jb2RlKGxvY2F0aW9uKTtcbiAgICBpZiAoZmFsbGJhY2tSZXN1bHQpIHtcbiAgICAgIGxvZ2dlci5sb2coJ1VzaW5nIGZhbGxiYWNrIGdlb2NvZGluZyByZXN1bHQ6JywgZmFsbGJhY2tSZXN1bHQpO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIElmIG5vIGZhbGxiYWNrIGZvdW5kLCByZXR1cm4gZGVmYXVsdCBjb29yZGluYXRlc1xuICAgIGxvZ2dlci53YXJuKCdObyBnZW9jb2RpbmcgcmVzdWx0IGZvdW5kLCB1c2luZyBkZWZhdWx0IGNvb3JkaW5hdGVzJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhdGl0dWRlOiAwLFxuICAgICAgbG9uZ2l0dWRlOiAwLFxuICAgICAgdGltZXpvbmU6ICdVVEMnXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ0Vycm9yIGluIGdlb2NvZGVCaXJ0aFBsYWNlOicsIGVycm9yKTtcbiAgICAvLyBSZXR1cm4gZGVmYXVsdCBjb29yZGluYXRlcyByYXRoZXIgdGhhbiB0aHJvd2luZ1xuICAgIHJldHVybiB7XG4gICAgICBsYXRpdHVkZTogMCxcbiAgICAgIGxvbmdpdHVkZTogMCxcbiAgICAgIHRpbWV6b25lOiAnVVRDJ1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBGYWxsYmFjayBnZW9jb2RpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgcHJlZGVmaW5lZCBsaXN0IG9mIGNpdGllc1xuICpcbiAqIEBwYXJhbSBsb2NhdGlvbiBMb2NhdGlvbiBzdHJpbmdcbiAqIEByZXR1cm5zIEdlb2NvZGluZyByZXN1bHQgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAqL1xuY29uc3QgZmFsbGJhY2tHZW9jb2RlID0gKGxvY2F0aW9uOiBzdHJpbmcpOiBHZW9jb2RpbmdSZXN1bHQgfCBudWxsID0+IHtcbiAgLy8gRXhhbXBsZSBtb2NrIGNvb3JkaW5hdGVzIGZvciBjb21tb24gY2l0aWVzXG4gIGNvbnN0IGdlb2NvZGVNYXA6IFJlY29yZDxzdHJpbmcsIHsgbGF0OiBudW1iZXI7IGxuZzogbnVtYmVyOyB0aW1lem9uZTogc3RyaW5nIH0+ID0ge1xuICAgICduZXcgeW9yayc6IHsgbGF0OiA0MC43MTI4LCBsbmc6IC03NC4wMDYwLCB0aW1lem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH0sXG4gICAgJ2xvbmRvbic6IHsgbGF0OiA1MS41MDc0LCBsbmc6IC0wLjEyNzgsIHRpbWV6b25lOiAnRXVyb3BlL0xvbmRvbicgfSxcbiAgICAndG9reW8nOiB7IGxhdDogMzUuNjc2MiwgbG5nOiAxMzkuNjUwMywgdGltZXpvbmU6ICdBc2lhL1Rva3lvJyB9LFxuICAgICdzeWRuZXknOiB7IGxhdDogLTMzLjg2ODgsIGxuZzogMTUxLjIwOTMsIHRpbWV6b25lOiAnQXVzdHJhbGlhL1N5ZG5leScgfSxcbiAgICAncHVuZSc6IHsgbGF0OiAxOC41MjA0LCBsbmc6IDczLjg1NjcsIHRpbWV6b25lOiAnQXNpYS9Lb2xrYXRhJyB9LFxuICAgICdwYXJpcyc6IHsgbGF0OiA0OC44NTY2LCBsbmc6IDIuMzUyMiwgdGltZXpvbmU6ICdFdXJvcGUvUGFyaXMnIH0sXG4gICAgJ2Jlcmxpbic6IHsgbGF0OiA1Mi41MjAwLCBsbmc6IDEzLjQwNTAsIHRpbWV6b25lOiAnRXVyb3BlL0JlcmxpbicgfSxcbiAgICAnZGVsaGknOiB7IGxhdDogMjguNjEzOSwgbG5nOiA3Ny4yMDkwLCB0aW1lem9uZTogJ0FzaWEvS29sa2F0YScgfSxcbiAgICAnbXVtYmFpJzogeyBsYXQ6IDE5LjA3NjAsIGxuZzogNzIuODc3NywgdGltZXpvbmU6ICdBc2lhL0tvbGthdGEnIH0sXG4gICAgJ2JhbmdhbG9yZSc6IHsgbGF0OiAxMi45NzE2LCBsbmc6IDc3LjU5NDYsIHRpbWV6b25lOiAnQXNpYS9Lb2xrYXRhJyB9LFxuICAgICdsb3MgYW5nZWxlcyc6IHsgbGF0OiAzNC4wNTIyLCBsbmc6IC0xMTguMjQzNywgdGltZXpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9LFxuICAgICdjaGljYWdvJzogeyBsYXQ6IDQxLjg3ODEsIGxuZzogLTg3LjYyOTgsIHRpbWV6b25lOiAnQW1lcmljYS9DaGljYWdvJyB9LFxuICAgICdtb3Njb3cnOiB7IGxhdDogNTUuNzU1OCwgbG5nOiAzNy42MTczLCB0aW1lem9uZTogJ0V1cm9wZS9Nb3Njb3cnIH0sXG4gICAgJ2JlaWppbmcnOiB7IGxhdDogMzkuOTA0MiwgbG5nOiAxMTYuNDA3NCwgdGltZXpvbmU6ICdBc2lhL1NoYW5naGFpJyB9LFxuICAgICdjYWlybyc6IHsgbGF0OiAzMC4wNDQ0LCBsbmc6IDMxLjIzNTcsIHRpbWV6b25lOiAnQWZyaWNhL0NhaXJvJyB9LFxuICAgICdyaW8gZGUgamFuZWlybyc6IHsgbGF0OiAtMjIuOTA2OCwgbG5nOiAtNDMuMTcyOSwgdGltZXpvbmU6ICdBbWVyaWNhL1Nhb19QYXVsbycgfSxcbiAgICAndG9yb250byc6IHsgbGF0OiA0My42NTMyLCBsbmc6IC03OS4zODMyLCB0aW1lem9uZTogJ0FtZXJpY2EvVG9yb250bycgfSxcbiAgICAncm9tZSc6IHsgbGF0OiA0MS45MDI4LCBsbmc6IDEyLjQ5NjQsIHRpbWV6b25lOiAnRXVyb3BlL1JvbWUnIH0sXG4gICAgJ21hZHJpZCc6IHsgbGF0OiA0MC40MTY4LCBsbmc6IC0zLjcwMzgsIHRpbWV6b25lOiAnRXVyb3BlL01hZHJpZCcgfSxcbiAgICAnc2luZ2Fwb3JlJzogeyBsYXQ6IDEuMzUyMSwgbG5nOiAxMDMuODE5OCwgdGltZXpvbmU6ICdBc2lhL1NpbmdhcG9yZScgfSxcbiAgfTtcblxuICAvLyBDaGVjayBpZiB3ZSBoYXZlIG1vY2sgZGF0YSBmb3IgdGhpcyBsb2NhdGlvbiAoY2FzZSBpbnNlbnNpdGl2ZSBwYXJ0aWFsIG1hdGNoKVxuICBjb25zdCBsb2NhdGlvbkxvd2VyID0gbG9jYXRpb24udG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgbWF0Y2hlZENpdHkgPSBPYmplY3Qua2V5cyhnZW9jb2RlTWFwKS5maW5kKGNpdHkgPT4gbG9jYXRpb25Mb3dlci5pbmNsdWRlcyhjaXR5KSk7XG5cbiAgaWYgKG1hdGNoZWRDaXR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhdGl0dWRlOiBnZW9jb2RlTWFwW21hdGNoZWRDaXR5XS5sYXQsXG4gICAgICBsb25naXR1ZGU6IGdlb2NvZGVNYXBbbWF0Y2hlZENpdHldLmxuZyxcbiAgICAgIHRpbWV6b25lOiBnZW9jb2RlTWFwW21hdGNoZWRDaXR5XS50aW1lem9uZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJsb2dnZXIiLCJsb2ciLCJtZXNzYWdlIiwiYXJncyIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwiZ2VvY29kZUJpcnRoUGxhY2UiLCJsb2NhdGlvbiIsImFwaVVybCIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJyZXNwb25zZSIsInBvc3QiLCJwbGFjZSIsInRpbWVvdXQiLCJkYXRhIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ0aW1lem9uZSIsImFwaUVycm9yIiwiZmFsbGJhY2tSZXN1bHQiLCJmYWxsYmFja0dlb2NvZGUiLCJnZW9jb2RlTWFwIiwibGF0IiwibG5nIiwibG9jYXRpb25Mb3dlciIsInRvTG93ZXJDYXNlIiwibWF0Y2hlZENpdHkiLCJPYmplY3QiLCJrZXlzIiwiZmluZCIsImNpdHkiLCJpbmNsdWRlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/services/geocoding.ts\n"));

/***/ })

});